// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Numerics;
using System.Runtime.CompilerServices;
namespace SmartV;

partial class ValueOperation
{

    /// <summary> Operates <c>add</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Add<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) + As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) + As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) + As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) + As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) + As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) + As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) + As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) + As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) + As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) + As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) + As<T, decimal>(y)));
        if(typeof(T) == typeof(Complex)) return As<Complex, T>((Complex)(As<T, Complex>(x) + As<T, Complex>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();

        return Cache<T>.Instance.Add(x, y);
    }


    /// <summary> Operates <c>addchecked</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T AddChecked<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) + As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) + As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) + As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) + As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) + As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) + As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) + As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) + As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) + As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) + As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) + As<T, decimal>(y)));
        if(typeof(T) == typeof(Complex)) return As<Complex, T>((Complex)(As<T, Complex>(x) + As<T, Complex>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();

        return Cache<T>.Instance.AddChecked(x, y);
    }


    /// <summary> Operates <c>subtract</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Subtract<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) - As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) - As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) - As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) - As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) - As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) - As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) - As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) - As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) - As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) - As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) - As<T, decimal>(y)));
        if(typeof(T) == typeof(Complex)) return As<Complex, T>((Complex)(As<T, Complex>(x) - As<T, Complex>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();

        return Cache<T>.Instance.Subtract(x, y);
    }


    /// <summary> Operates <c>subtractchecked</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T SubtractChecked<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) - As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) - As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) - As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) - As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) - As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) - As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) - As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) - As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) - As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) - As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) - As<T, decimal>(y)));
        if(typeof(T) == typeof(Complex)) return As<Complex, T>((Complex)(As<T, Complex>(x) - As<T, Complex>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();

        return Cache<T>.Instance.SubtractChecked(x, y);
    }


    /// <summary> Operates <c>multiply</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Multiply<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) * As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) * As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) * As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) * As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) * As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) * As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) * As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) * As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) * As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) * As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) * As<T, decimal>(y)));
        if(typeof(T) == typeof(Complex)) return As<Complex, T>((Complex)(As<T, Complex>(x) * As<T, Complex>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();

        return Cache<T>.Instance.Multiply(x, y);
    }


    /// <summary> Operates <c>multiplychecked</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T MultiplyChecked<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) * As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) * As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) * As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) * As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) * As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) * As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) * As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) * As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) * As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) * As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) * As<T, decimal>(y)));
        if(typeof(T) == typeof(Complex)) return As<Complex, T>((Complex)(As<T, Complex>(x) * As<T, Complex>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();

        return Cache<T>.Instance.MultiplyChecked(x, y);
    }


    /// <summary> Operates <c>divide</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Divide<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) / As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) / As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) / As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) / As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) / As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) / As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) / As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) / As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) / As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) / As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) / As<T, decimal>(y)));
        if(typeof(T) == typeof(Complex)) return As<Complex, T>((Complex)(As<T, Complex>(x) / As<T, Complex>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();

        return Cache<T>.Instance.Divide(x, y);
    }


    /// <summary> Operates <c>modulo</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Modulo<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) % As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) % As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) % As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) % As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) % As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) % As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) % As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) % As<T, long   >(y)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(As<T, float  >(x) % As<T, float  >(y)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(As<T, double >(x) % As<T, double >(y)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(As<T, decimal>(x) % As<T, decimal>(y)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();
        if(typeof(T) == typeof(Complex)) throw new NotSupportedException();

        return Cache<T>.Instance.Modulo(x, y);
    }


    /// <summary> Operates <c>bitwiseor</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T BitwiseOr<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(bool   )) return As<bool   , T>((bool   )(As<T, bool   >(x) | As<T, bool   >(y)));
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) | As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) | As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) | As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) | As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) | As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) | As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) | As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) | As<T, long   >(y)));

        if(typeof(T) == typeof(float  )) throw new NotSupportedException();
        if(typeof(T) == typeof(double )) throw new NotSupportedException();
        if(typeof(T) == typeof(decimal)) throw new NotSupportedException();
        if(typeof(T) == typeof(Complex)) throw new NotSupportedException();

        return Cache<T>.Instance.BitwiseOr(x, y);
    }


    /// <summary> Operates <c>bitwiseand</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T BitwiseAnd<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(bool   )) return As<bool   , T>((bool   )(As<T, bool   >(x) & As<T, bool   >(y)));
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) & As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) & As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) & As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) & As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) & As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) & As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) & As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) & As<T, long   >(y)));

        if(typeof(T) == typeof(float  )) throw new NotSupportedException();
        if(typeof(T) == typeof(double )) throw new NotSupportedException();
        if(typeof(T) == typeof(decimal)) throw new NotSupportedException();
        if(typeof(T) == typeof(Complex)) throw new NotSupportedException();

        return Cache<T>.Instance.BitwiseAnd(x, y);
    }


    /// <summary> Operates <c>bitwisexor</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T BitwiseXor<T>(in T x, in T y)
    {
        if(typeof(T) == typeof(bool   )) return As<bool   , T>((bool   )(As<T, bool   >(x) ^ As<T, bool   >(y)));
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(As<T, byte   >(x) ^ As<T, byte   >(y)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(As<T, ushort >(x) ^ As<T, ushort >(y)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(As<T, uint   >(x) ^ As<T, uint   >(y)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(As<T, ulong  >(x) ^ As<T, ulong  >(y)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(As<T, sbyte  >(x) ^ As<T, sbyte  >(y)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(As<T, short  >(x) ^ As<T, short  >(y)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(As<T, int    >(x) ^ As<T, int    >(y)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(As<T, long   >(x) ^ As<T, long   >(y)));

        if(typeof(T) == typeof(float  )) throw new NotSupportedException();
        if(typeof(T) == typeof(double )) throw new NotSupportedException();
        if(typeof(T) == typeof(decimal)) throw new NotSupportedException();
        if(typeof(T) == typeof(Complex)) throw new NotSupportedException();

        return Cache<T>.Instance.BitwiseXor(x, y);
    }

}

