// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Runtime.CompilerServices;
namespace SmartV;

partial class ValueOperation
{

    /// <summary> Operates <c>UnaryPlus</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T UnaryPlus<T>(in T x)
    {
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(+As<T, sbyte  >(x)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(+As<T, short  >(x)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(+As<T, int    >(x)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(+As<T, long   >(x)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(+As<T, float  >(x)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(+As<T, double >(x)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(+As<T, decimal>(x)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();
        if(typeof(T) == typeof(byte   )) throw new NotSupportedException();
        if(typeof(T) == typeof(ushort )) throw new NotSupportedException();
        if(typeof(T) == typeof(uint   )) throw new NotSupportedException();
        if(typeof(T) == typeof(ulong  )) throw new NotSupportedException();

        return Cache<T>.Instance.UnaryPlus(x);
    }


    /// <summary> Operates <c>UnaryMinus</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T UnaryMinus<T>(in T x)
    {
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(-As<T, sbyte  >(x)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(-As<T, short  >(x)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(-As<T, int    >(x)));
        if(typeof(T) == typeof(float  )) return As<float  , T>((float  )(-As<T, float  >(x)));
        if(typeof(T) == typeof(double )) return As<double , T>((double )(-As<T, double >(x)));
        if(typeof(T) == typeof(decimal)) return As<decimal, T>((decimal)(-As<T, decimal>(x)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();
        if(typeof(T) == typeof(byte   )) throw new NotSupportedException();
        if(typeof(T) == typeof(ushort )) throw new NotSupportedException();
        if(typeof(T) == typeof(uint   )) throw new NotSupportedException();
        if(typeof(T) == typeof(ulong  )) throw new NotSupportedException();
        if(typeof(T) == typeof(long   )) throw new NotSupportedException();

        return Cache<T>.Instance.UnaryMinus(x);
    }


    /// <summary> Operates <c>Not</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Not<T>(in T x)
    {
        if(typeof(T) == typeof(bool   )) return As<bool   , T>((bool   )(!As<T, bool   >(x)));

        if(typeof(T) == typeof(byte   )) throw new NotSupportedException();
        if(typeof(T) == typeof(ushort )) throw new NotSupportedException();
        if(typeof(T) == typeof(uint   )) throw new NotSupportedException();
        if(typeof(T) == typeof(ulong  )) throw new NotSupportedException();
        if(typeof(T) == typeof(sbyte  )) throw new NotSupportedException();
        if(typeof(T) == typeof(short  )) throw new NotSupportedException();
        if(typeof(T) == typeof(int    )) throw new NotSupportedException();
        if(typeof(T) == typeof(long   )) throw new NotSupportedException();
        if(typeof(T) == typeof(float  )) throw new NotSupportedException();
        if(typeof(T) == typeof(double )) throw new NotSupportedException();
        if(typeof(T) == typeof(decimal)) throw new NotSupportedException();

        return Cache<T>.Instance.Not(x);
    }


    /// <summary> Operates <c>Complement</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static T Complement<T>(in T x)
    {
        if(typeof(T) == typeof(byte   )) return As<byte   , T>((byte   )(~As<T, byte   >(x)));
        if(typeof(T) == typeof(ushort )) return As<ushort , T>((ushort )(~As<T, ushort >(x)));
        if(typeof(T) == typeof(uint   )) return As<uint   , T>((uint   )(~As<T, uint   >(x)));
        if(typeof(T) == typeof(ulong  )) return As<ulong  , T>((ulong  )(~As<T, ulong  >(x)));
        if(typeof(T) == typeof(sbyte  )) return As<sbyte  , T>((sbyte  )(~As<T, sbyte  >(x)));
        if(typeof(T) == typeof(short  )) return As<short  , T>((short  )(~As<T, short  >(x)));
        if(typeof(T) == typeof(int    )) return As<int    , T>((int    )(~As<T, int    >(x)));
        if(typeof(T) == typeof(long   )) return As<long   , T>((long   )(~As<T, long   >(x)));

        if(typeof(T) == typeof(bool   )) throw new NotSupportedException();
        if(typeof(T) == typeof(float  )) throw new NotSupportedException();
        if(typeof(T) == typeof(double )) throw new NotSupportedException();
        if(typeof(T) == typeof(decimal)) throw new NotSupportedException();

        return Cache<T>.Instance.Complement(x);
    }

}
