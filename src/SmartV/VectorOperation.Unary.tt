<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var operations = new (string, Func<string, string>, Func<string, string>) [] {
    ("UnaryPlus" , x =>$"{x}", x =>$"ValueOperation.UnaryPlus({x})"),
    ("UnaryMinus", x =>$"-{x}", x =>$"ValueOperation.UnaryMinus({x})"),
    ("Complement", x =>$"~{x}", x =>$"ValueOperation.Complement({x})"),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#nullable enable
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace SmartV;
<# foreach(var (opname, v_op, s_op) in operations) { #>

partial interface IVectorOperation
{
    /// <summary> Operates <c><#=opname#></c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <exception cref="ArgumentException">
    /// The length of <paramref name="x"/> and <paramref name="ans"/> must be same.
    /// </exception>
    /// <exception cref="NotSupportedException" />
    void <#=opname#><T>(ReadOnlySpan<T> x, Span<T> ans) where T : unmanaged;
}

unsafe partial class VectorOperation
{
    partial class _Default
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void <#=opname#><T>(ReadOnlySpan<T> x, Span<T> ans) where T : unmanaged
        {
            AssertSizeMatch(x, ans, nameof(x), nameof(ans));
            
            var len = ans.Length;
            var i = 0;
            if(typeof(T) == typeof(byte)
                || typeof(T) == typeof(ushort)
                || typeof(T) == typeof(uint)
                || typeof(T) == typeof(ulong)
                || typeof(T) == typeof(sbyte)
                || typeof(T) == typeof(short)
                || typeof(T) == typeof(int)
                || typeof(T) == typeof(long)
                || typeof(T) == typeof(float)
                || typeof(T) == typeof(double))
            {
                var vlen = GetVectorizableLength(ans);
                var vx = Cast(x, vlen);
                var vans = Cast(ans, vlen);
                for(var j = 0; j < vans.Length; ++j)
                {
                    vans[j] = <#=v_op("vx[j]")#>;
                }
                i = vlen;
            }
            for(; i < ans.Length; ++i)
            {
                ans[i] = <#=s_op("x[i]")#>;
            }
        }
    }

    
    partial class _Parallelized
    {
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void <#=opname#><T>(ReadOnlySpan<T> x, Span<T> ans) where T : unmanaged
        {
            AssertSizeMatch(x, ans, nameof(x), nameof(ans));
            
            var len = ans.Length;
            var i = 0;
            if(typeof(T) == typeof(byte)
                || typeof(T) == typeof(ushort)
                || typeof(T) == typeof(uint)
                || typeof(T) == typeof(ulong)
                || typeof(T) == typeof(sbyte)
                || typeof(T) == typeof(short)
                || typeof(T) == typeof(int)
                || typeof(T) == typeof(long)
                || typeof(T) == typeof(float)
                || typeof(T) == typeof(double))
            {
                var vlen = GetVectorizableLength(ans);
                var vx = Cast(x, vlen);
                var vans = Cast(ans, vlen);
                fixed(Vector<T>* ptr_vx = vx)
                fixed(Vector<T>* ptr_vans = vans)
                {
                    var _ptr_vx = ptr_vx;
                    var _ptr_vans = ptr_vans;
                    Parallel.For(0, vans.Length, Options, j =>
                    {
                        _ptr_vans[j] = <#=v_op("_ptr_vx[j]")#>;
                    });
                }
                i = vlen;
            }
            for(; i < ans.Length; ++i)
            {
                ans[i] = <#=s_op("x[i]")#>;
            }
        }
    }
}

<# } #>