// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
#nullable enable
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
namespace SmartV;

unsafe partial class VectorOperation
{

    /// <summary> Operates <c>UnaryPlus</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <param name="iterationStrategy">
    /// <para>The iteration strategy provider.</para>
    /// <para>If <c>null</c> or <see cref="IterationStrategy.Default"/>, the iteration logic will be optimized with standard for-loop.</para>
    /// </param>
    /// <exception cref="ArgumentException">
    /// The length of <paramref name="x"/> and <paramref name="ans"/> must be same.
    /// </exception>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void UnaryPlus<T>(ReadOnlySpan<T> x, Span<T> ans, IIterationStrategy? iterationStrategy = null)
        where T : unmanaged
    {
        AssertSizeMatch(x, ans, nameof(x), nameof(ans));
            
        var len = ans.Length;
        var i = 0;
        if(typeof(T) == typeof(byte)
            || typeof(T) == typeof(ushort)
            || typeof(T) == typeof(uint)
            || typeof(T) == typeof(ulong)
            || typeof(T) == typeof(sbyte)
            || typeof(T) == typeof(short)
            || typeof(T) == typeof(int)
            || typeof(T) == typeof(long)
            || typeof(T) == typeof(float)
            || typeof(T) == typeof(double))
        {
            var vlen = GetVectorizableLength(ans);
            var vx = Cast(x, vlen);
            var vans = Cast(ans, vlen);
            if(iterationStrategy.IsDefault())
            {
                for(var j = 0; j < vans.Length; ++j)
                {
                    vans[j] = vx[j];
                }
            }
            else
            {
                fixed(Vector<T>* ptr_vx = vx)
                fixed(Vector<T>* ptr_vans = vans)
                {
                    var _ptr_vx = ptr_vx;
                    var _ptr_vans = ptr_vans;
                    iterationStrategy!.For(0, vans.Length, j =>
                    {
                        _ptr_vans[j] = _ptr_vx[j];
                    });
                }
            }
            i = vlen;
        }
        for(; i < ans.Length; ++i)
        {
            ans[i] = ValueOperation.UnaryPlus(x[i]);
        }
    }


    /// <summary> Operates <c>UnaryMinus</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <param name="iterationStrategy">
    /// <para>The iteration strategy provider.</para>
    /// <para>If <c>null</c> or <see cref="IterationStrategy.Default"/>, the iteration logic will be optimized with standard for-loop.</para>
    /// </param>
    /// <exception cref="ArgumentException">
    /// The length of <paramref name="x"/> and <paramref name="ans"/> must be same.
    /// </exception>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void UnaryMinus<T>(ReadOnlySpan<T> x, Span<T> ans, IIterationStrategy? iterationStrategy = null)
        where T : unmanaged
    {
        AssertSizeMatch(x, ans, nameof(x), nameof(ans));
            
        var len = ans.Length;
        var i = 0;
        if(typeof(T) == typeof(byte)
            || typeof(T) == typeof(ushort)
            || typeof(T) == typeof(uint)
            || typeof(T) == typeof(ulong)
            || typeof(T) == typeof(sbyte)
            || typeof(T) == typeof(short)
            || typeof(T) == typeof(int)
            || typeof(T) == typeof(long)
            || typeof(T) == typeof(float)
            || typeof(T) == typeof(double))
        {
            var vlen = GetVectorizableLength(ans);
            var vx = Cast(x, vlen);
            var vans = Cast(ans, vlen);
            if(iterationStrategy.IsDefault())
            {
                for(var j = 0; j < vans.Length; ++j)
                {
                    vans[j] = -vx[j];
                }
            }
            else
            {
                fixed(Vector<T>* ptr_vx = vx)
                fixed(Vector<T>* ptr_vans = vans)
                {
                    var _ptr_vx = ptr_vx;
                    var _ptr_vans = ptr_vans;
                    iterationStrategy!.For(0, vans.Length, j =>
                    {
                        _ptr_vans[j] = -_ptr_vx[j];
                    });
                }
            }
            i = vlen;
        }
        for(; i < ans.Length; ++i)
        {
            ans[i] = ValueOperation.UnaryMinus(x[i]);
        }
    }


    /// <summary> Operates <c>Complement</c> unaly operation. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="ans"></param>
    /// <param name="iterationStrategy">
    /// <para>The iteration strategy provider.</para>
    /// <para>If <c>null</c> or <see cref="IterationStrategy.Default"/>, the iteration logic will be optimized with standard for-loop.</para>
    /// </param>
    /// <exception cref="ArgumentException">
    /// The length of <paramref name="x"/> and <paramref name="ans"/> must be same.
    /// </exception>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static void Complement<T>(ReadOnlySpan<T> x, Span<T> ans, IIterationStrategy? iterationStrategy = null)
        where T : unmanaged
    {
        AssertSizeMatch(x, ans, nameof(x), nameof(ans));
            
        var len = ans.Length;
        var i = 0;
        if(typeof(T) == typeof(byte)
            || typeof(T) == typeof(ushort)
            || typeof(T) == typeof(uint)
            || typeof(T) == typeof(ulong)
            || typeof(T) == typeof(sbyte)
            || typeof(T) == typeof(short)
            || typeof(T) == typeof(int)
            || typeof(T) == typeof(long)
            || typeof(T) == typeof(float)
            || typeof(T) == typeof(double))
        {
            var vlen = GetVectorizableLength(ans);
            var vx = Cast(x, vlen);
            var vans = Cast(ans, vlen);
            if(iterationStrategy.IsDefault())
            {
                for(var j = 0; j < vans.Length; ++j)
                {
                    vans[j] = ~vx[j];
                }
            }
            else
            {
                fixed(Vector<T>* ptr_vx = vx)
                fixed(Vector<T>* ptr_vans = vans)
                {
                    var _ptr_vx = ptr_vx;
                    var _ptr_vans = ptr_vans;
                    iterationStrategy!.For(0, vans.Length, j =>
                    {
                        _ptr_vans[j] = ~_ptr_vx[j];
                    });
                }
            }
            i = vlen;
        }
        for(; i < ans.Length; ++i)
        {
            ans[i] = ValueOperation.Complement(x[i]);
        }
    }

}