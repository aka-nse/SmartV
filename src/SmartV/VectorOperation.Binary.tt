<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var operations = new (string, Func<string, string, string>, Func<string, string, string>) [] {
    ("Add"            , (x, y) =>$"{x} + {y}", (x, y) =>$"ValueOperation.Add({x}, {y})"),
    ("AddChecked"     , (x, y) =>$"{x} + {y}", (x, y) =>$"ValueOperation.AddChecked({x}, {y})"),
    ("Subtract"       , (x, y) =>$"{x} - {y}", (x, y) =>$"ValueOperation.Subtract({x}, {y})"),
    ("SubtractChecked", (x, y) =>$"{x} - {y}", (x, y) =>$"ValueOperation.SubtractChecked({x}, {y})"),
    ("Multiply"       , (x, y) =>$"{x} * {y}", (x, y) =>$"ValueOperation.Multiply({x}, {y})"),
    ("MultiplyChecked", (x, y) =>$"{x} * {y}", (x, y) =>$"ValueOperation.MultiplyChecked({x}, {y})"),
    ("Divide"         , (x, y) =>$"{x} / {y}", (x, y) =>$"ValueOperation.Divide({x}, {y})"),
    ("Modulo"         , (x, y) =>$"{x} - {y} * ({x} / {y})", (x, y) =>$"ValueOperation.Modulo({x}, {y})"),
    ("BitwiseOr"      , (x, y) =>$"{x} | {y}", (x, y) =>$"ValueOperation.BitwiseOr({x}, {y})"),
    ("BitwiseAnd"     , (x, y) =>$"{x} & {y}", (x, y) =>$"ValueOperation.BitwiseAnd({x}, {y})"),
    ("BitwiseXor"     , (x, y) =>$"{x} ^ {y}", (x, y) =>$"ValueOperation.BitwiseXor({x}, {y})"),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>

#nullable enable
using System;
using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

namespace SmartV
{
    unsafe partial class VectorOperation
    {
<# foreach(var (opname, v_op, s_op) in operations) { #>

        /// <summary> Operates <c><#=opname#></c> unaly operation. </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <param name="ans"></param>
        /// <param name="iterationStrategy">
        /// <para>The iteration strategy provider.</para>
        /// <para>If <c>null</c> or <see cref="IterationStrategy.Default"/>, the iteration logic will be optimized with standard for-loop.</para>
        /// </param>
        /// <exception cref="ArgumentException">
        /// <para>The length of <paramref name="x"/> and <paramref name="ans"/> must be same.</para>
        /// <para>or</para>
        /// <para>The length of <paramref name="y"/> and <paramref name="ans"/> must be same.</para>
        /// </exception>
        /// <exception cref="NotSupportedException" />
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void <#=opname#><T>(ReadOnlySpan<T> x, ReadOnlySpan<T> y, Span<T> ans, IIterationStrategy? iterationStrategy = null)
            where T : unmanaged
        {
            AssertSizeMatch(x, ans, nameof(x), nameof(ans));
            AssertSizeMatch(y, ans, nameof(y), nameof(ans));
            
            var len = ans.Length;
            var i = 0;
            if(typeof(T) == typeof(byte)
               || typeof(T) == typeof(ushort)
               || typeof(T) == typeof(uint)
               || typeof(T) == typeof(ulong)
               || typeof(T) == typeof(sbyte)
               || typeof(T) == typeof(short)
               || typeof(T) == typeof(int)
               || typeof(T) == typeof(long)
               || typeof(T) == typeof(float)
               || typeof(T) == typeof(double))
            {
                var vlen = GetVectorizableLength(ans);
                var vx = Cast(x, vlen);
                var vy = Cast(y, vlen);
                var vans = Cast(ans, vlen);
                if(iterationStrategy.IsDefault())
                {
                    for(var j = 0; j < vans.Length; ++j)
                    {
                        vans[j] = <#=v_op("vx[j]", "vy[j]")#>;
                    }
                }
                else
                {
                    fixed(Vector<T>* ptr_vx = vx)
                    fixed(Vector<T>* ptr_vy = vy)
                    fixed(Vector<T>* ptr_vans = vans)
                    {
                        var _ptr_vx = ptr_vx;
                        var _ptr_vy = ptr_vy;
                        var _ptr_vans = ptr_vans;
                        iterationStrategy!.For(0, vans.Length, j =>
                        {
                            _ptr_vans[j] = <#=v_op("_ptr_vx[j]", "_ptr_vy[j]")#>;
                        });
                    }
                }
                i = vlen;
            }
            for(; i < ans.Length; ++i)
            {
                ans[i] = <#=s_op("x[i]", "y[i]")#>;
            }
        }

<# } #>
    }
}