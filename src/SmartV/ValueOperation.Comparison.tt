<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".g.cs" #>
<#
var types = new []{
    new TypeDef("bool   ", false),
    new TypeDef("byte   ", true ),
    new TypeDef("ushort ", true ),
    new TypeDef("uint   ", true ),
    new TypeDef("ulong  ", true ),
    new TypeDef("sbyte  ", true ),
    new TypeDef("short  ", true ),
    new TypeDef("int    ", true ),
    new TypeDef("long   ", true ),
    new TypeDef("float  ", false),
    new TypeDef("double ", false),
    new TypeDef("decimal", false),
};
#>
// <auto-generated>
// THIS (.cs) FILE IS GENERATED BY T4. DO NOT CHANGE IT. CHANGE THE .tt FILE INSTEAD.
// </auto-generated>
using System.Runtime.CompilerServices;
namespace SmartV;

partial class ValueOperation
{
    /// <summary> Compares 2 values of <typeparamref name="T"/>. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool Equals<T>(in T x, in T y)
    {
<# foreach(var type in types) { #>
        if(typeof(T) == typeof(<#=type#>)) return As<T, <#=type#>>(x) == As<T, <#=type#>>(y);
<# } #>

        return Cache<T>.Instance.Equals(x, y);
    }


    /// <summary> Compares 2 values of <typeparamref name="T"/>. </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="x"></param>
    /// <param name="y"></param>
    /// <returns></returns>
    /// <exception cref="NotSupportedException" />
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static int Compare<T>(in T x, in T y)
    {
<# foreach(var type in types.Where(type => type.ComparisonSupported)) { #>
        if(typeof(T) == typeof(<#=type#>))
        {
            var xx = As<T, <#=type#>>(x);
            var yy = As<T, <#=type#>>(y);
            return (xx == yy) ? 0 : ((xx > yy) ? 1 : -1);
        }
<# } #>

<# foreach(var type in types.Where(type => !type.ComparisonSupported)) { #>
        if(typeof(T) == typeof(<#=type#>)) throw new NotSupportedException();
<# } #>

        return Cache<T>.Instance.Compare(x, y);
    }
}
<#+
public struct TypeDef
{
    public string Name { get; }
    public bool ComparisonSupported { get; }

    public TypeDef(string name, bool comparisonSupported)
    {
        Name = name;
        ComparisonSupported = comparisonSupported;
    }

    public override string ToString() => Name.PadRight(7);
}
#>